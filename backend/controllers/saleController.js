// backend/controllers/saleController.js
// This file handles all sales-related API logic.
// It interacts with the Supabase database.

const supabase = require('../config/supabaseClient'); // Import the Supabase client
const PDFDocument = require('pdfkit'); // For PDF generation
const fs = require('fs'); // Node.js file system module

// --- SALES API CONTROLLERS ---

// Create a new sale (header and line items)
exports.createSale = async (req, res) => {
    console.log(`[${new Date().toISOString()}] POST /api/sales called. Body:`, req.body);
    const { line_items, ...saleHeaderData } = req.body;

    // --- CRITICAL FIXES FOR SUBTOTAL AND OTHER NUMERIC FIELDS ---
    // Parse and validate subtotal from incoming request body
    const parsedSubtotal = parseFloat(saleHeaderData.subtotal);

    // Basic validation for sale header required fields
    // This check now correctly handles if subtotal is missing or evaluates to NaN
    if (!saleHeaderData.sale_date || !saleHeaderData.customer_name || !saleHeaderData.payment_method ||
        isNaN(parsedSubtotal)) { // Check if parsedSubtotal is NaN
        return res.status(400).json({ message: 'Missing or invalid required sale header fields: sale_date, customer_name, payment_method, subtotal must be a valid number.' });
    }

    if (!Array.isArray(line_items) || line_items.length === 0) {
        return res.status(400).json({ message: 'Sale must include at least one line item.' });
    }

    try {
        // 1. Insert into sale_header
        const headerInsertData = {
            sale_date: saleHeaderData.sale_date,
            customer_name: saleHeaderData.customer_name,
            contact_type: saleHeaderData.contact_type || null,
            contact_info: saleHeaderData.contact_info || null,
            payment_method: saleHeaderData.payment_method,
            // Use parseFloat and default to 0 if the original value is not a valid number (e.g., null, undefined, "")
            discount_percent: parseFloat(saleHeaderData.discount_percent || 0),
            tax_amount: parseFloat(saleHeaderData.tax_amount || 0),
            transaction_fee: parseFloat(saleHeaderData.transaction_fee || 0),
            subtotal: parsedSubtotal, // Use the already parsed and validated subtotal
            invoice_number: saleHeaderData.invoice_number || null,
            notes: saleHeaderData.notes || null,
        };

        const { data: headerData, error: headerError } = await supabase
            .from('sale_header')
            .insert([headerInsertData])
            // Select all relevant columns from headerData including the ones that are generated by DB functions
            .select('id, invoice_number, subtotal, discount_amount, total_amount, tax_amount, transaction_fee');

        if (headerError) {
            console.error("Supabase Error - createSale (header):", headerError);
            // Log full Supabase error for better debugging
            if (headerError.details) console.error("Supabase Error Details:", headerError.details);
            if (headerError.hint) console.error("Supabase Error Hint:", headerError.hint);
            return res.status(500).json({ message: 'Error creating sale header', error: headerError.message });
        }

        const sale_header_id = headerData[0].id;
        const invoice_number = headerData[0].invoice_number;
        // These are now guaranteed to be numbers as they come from the DB after insert
        const calculatedSubtotal = headerData[0].subtotal;
        const calculatedDiscountAmount = headerData[0].discount_amount;
        const calculatedTotalAmount = headerData[0].total_amount;
        const calculatedTaxAmount = headerData[0].tax_amount;
        const calculatedTransactionFee = headerData[0].transaction_fee;


        // 2. Prepare line items for batch insert
        const lineItemsToInsert = line_items.map(item => ({
            sale_id: sale_header_id,
            product_id: parseInt(item.product_id), // Ensure product_id is an integer
            consignor_id: parseInt(item.consignor_id), // Ensure consignor_id is an integer
            agreement_id: item.agreement_id ? parseInt(item.agreement_id) : null, // Handle optional agreement_id
            quantity: parseInt(item.quantity), // Ensure quantity is an integer
            unit_price: parseFloat(item.unit_price), // Ensure unit_price is a float
            commission: parseFloat(item.commission), // Ensure commission is a float
        }));

        const { data: lineData, error: lineError } = await supabase
            .from('sale_items')
            .insert(lineItemsToInsert)
            .select(); // Select inserted data to confirm

        if (lineError) {
            console.error("Supabase Error - createSale (line items):", lineError);
            // Log full Supabase error for better debugging
            if (lineError.details) console.error("Supabase Error Details:", lineError.details);
            if (lineError.hint) console.error("Supabase Error Hint:", lineError.hint);
            // IMPORTANT: Rollback the header if line item insertion fails to maintain data integrity
            await supabase.from('sale_header').delete().eq('id', sale_header_id);
            return res.status(500).json({ message: 'Error creating sale line items. Sale header rolled back.', error: lineError.message });
        }

        console.log(`[${new Date().toISOString()}] Sale created successfully with ID: ${sale_header_id}, Invoice: ${invoice_number}`);

        // Fetch the newly created sale with joined data for immediate frontend response
        const { data: newSaleData, error: fetchNewSaleError } = await supabase
            .from('sale_header')
            .select(`
                id,
                sale_date,
                payment_method,
                customer_name,
                invoice_number,
                notes,
                subtotal,
                discount_amount,
                total_amount,
                tax_amount,
                transaction_fee,
                sale_items (
                    product_id,
                    quantity,
                    unit_price,
                    commission,
                    line_total,
                    products(name),
                    consignors(full_name)
                )
            `)
            .eq('id', sale_header_id)
            .single();

        if (fetchNewSaleError) {
            console.error("Supabase Error - createSale (fetching new sale for response):", fetchNewSaleError);
            return res.status(500).json({ message: 'Sale recorded, but failed to retrieve full sale data for response.', error: fetchNewSaleError.message });
        }

        // Aggregate data for frontendSale object
        let totalCommission = 0;
        let productNameForDisplay = 'Multiple Products';
        let consignorNameForDisplay = 'Multiple Consignors';

        if (newSaleData.sale_items && newSaleData.sale_items.length > 0) {
            newSaleData.sale_items.forEach(item => {
                totalCommission += item.commission;
            });

            // If only one item, get specific product/consignor name
            if (newSaleData.sale_items.length === 1) {
                productNameForDisplay = newSaleData.sale_items[0].products?.name || 'N/A';
                consignorNameForDisplay = newSaleData.sale_items[0].consignors?.full_name || 'N/A';
            }
        }

        const frontendSale = {
            id: newSaleData.id,
            saleDate: newSaleData.sale_date,
            paymentMethod: newSaleData.payment_method,
            customerName: newSaleData.customer_name,
            productName: productNameForDisplay,
            amount: newSaleData.total_amount, // Use the total_amount calculated by the DB
            commission: totalCommission, // Sum of commissions from line items
            consignorId: newSaleData.sale_items[0]?.consignors?.id || null, // For single item, display its consignor ID
            consignorName: consignorNameForDisplay,
            subtotal: newSaleData.subtotal,
            discountAmount: newSaleData.discount_amount,
            taxAmount: newSaleData.tax_amount,
            transactionFee: newSaleData.transaction_fee,
            invoiceNumber: newSaleData.invoice_number,
            notes: newSaleData.notes,
            lineItems: newSaleData.sale_items,
        };

        res.status(201).json({
            message: 'Sale recorded successfully!',
            saleId: sale_header_id,
            invoiceNumber: invoice_number,
            newSale: frontendSale
        });

    } catch (err) {
        console.error("Server Error - createSale (Catch Block):", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// Get all sales with their line items, products, and consignor details
exports.getAllSales = async (req, res) => {
    console.log(`[${new Date().toISOString()}] GET /api/sales called.`);
    try {
        // Fetch sales data, joining all necessary tables
        const { data: salesData, error } = await supabase
            .from('sale_header')
            .select(`
                id,
                sale_date,
                customer_name,
                payment_method,
                subtotal,
                discount_percent,
                discount_amount,
                tax_amount,
                transaction_fee,
                total_amount,
                sale_items!inner (
                    product_id,
                    quantity,
                    unit_price,
                    commission,
                    line_total,
                    net_amount,
                    products!inner (
                        id,
                        name,
                        consignor_id,
                        consignors!inner (
                            id,
                            full_name
                        )
                    )
                )
            `)
            .order('sale_date', { ascending: false }); // Order by newest sales first

        if (error) {
            console.error("Supabase Error - getAllSales:", error);
            return res.status(500).json({ message: 'Error fetching sales from database', error: error.message });
        }

        // Transform the fetched data into the `Sale` interface structure expected by the frontend
        const transformedSales = salesData.map(header => {
            let productName = "Multiple Products";
            let consignorName = "Multiple Consignors";
            let consignorId = null;
            let firstProduct = true;

            let totalCommission = 0;

            if (header.sale_items && header.sale_items.length > 0) {
                header.sale_items.forEach(lineItem => {
                    totalCommission += lineItem.commission;

                    // This logic assumes `products` and `consignors` are always available for inner joins
                    if (firstProduct && lineItem.products) {
                        productName = lineItem.products.name;
                        consignorName = lineItem.products.consignors?.full_name || 'Unknown';
                        consignorId = lineItem.products.consignors?.id || null;
                        firstProduct = false; // Only get first product's details if there are multiple
                    }
                });
            } else {
                productName = "No Products";
                consignorName = "N/A";
            }

            return {
                id: header.id,
                saleDate: header.sale_date,
                productName: productName,
                consignorName: consignorName,
                amount: header.total_amount,
                commission: totalCommission, // Aggregated commission
                paymentMethod: header.payment_method,
                consignorId: consignorId, // Consignor ID for display (if single product)
                subtotal: header.subtotal,
                discountPercent: header.discount_percent,
                discountAmount: header.discount_amount,
                taxAmount: header.tax_amount,
                transactionFee: header.transaction_fee,
                lineItems: header.sale_items.map(item => ({
                    productId: item.product_id,
                    quantity: item.quantity,
                    unitPrice: item.unit_price,
                    commission: item.commission,
                    lineTotal: item.line_total,
                    netAmount: item.net_amount,
                    productName: item.products?.name,
                    consignorName: item.products?.consignors?.full_name,
                })),
            };
        });

        console.log(`[${new Date().toISOString()}] Returning ${transformedSales.length} transformed sales from DB.`);
        res.status(200).json(transformedSales);
    } catch (err) {
        console.error("Server Error - getAllSales:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// Get a single sale by ID with its line items
exports.getSaleById = async (req, res) => {
    const saleId = req.params.id;
    console.log(`[${new Date().toISOString()}] GET /api/sales/${saleId} called.`);

    // UUID validation
    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(saleId)) {
        return res.status(400).json({ message: 'Invalid Sale ID format (must be a UUID).' });
    }

    try {
        const { data, error } = await supabase
            .from('sale_header')
            .select(`
                *,
                sale_items (
                    *,
                    products (name),       // Join products to get product name
                    consignors (full_name) // Join consignors to get consignor name
                )
            `)
            .eq('id', saleId)
            .single();

        if (error) {
            console.error(`Supabase Error - getSaleById for ID ${saleId}:`, error);
            if (error.code === 'PGRST116') { // Supabase code for "No rows found"
                return res.status(404).json({ message: `Sale with ID ${saleId} not found.` });
            }
            return res.status(500).json({ message: 'Error fetching sale from database', error: error.message });
        }

        if (!data) { // Should be caught by PGRST116, but good defensive check
            return res.status(404).json({ message: `Sale with ID ${saleId} not found.` });
        }

        console.log(`[${new Date().toISOString()}] Returning sale with ID ${saleId}:`, data);
        res.status(200).json(data);
    } catch (err) {
        console.error("Server Error - getSaleById:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// Update an existing sale header by ID
exports.updateSaleHeader = async (req, res) => {
    const saleId = req.params.id;
    const updateData = req.body;
    console.log(`[${new Date().toISOString()}] PUT /api/sales/${saleId} called. Update data:`, updateData);

    // UUID validation
    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(saleId)) {
        return res.status(400).json({ message: 'Invalid Sale ID format (must be a UUID).' });
    }

    const allowedFields = [
        'sale_date', 'customer_name', 'contact_type', 'contact_info',
        'payment_method', 'discount_percent', 'tax_amount', 'transaction_fee',
        'subtotal', 'invoice_number', 'notes'
    ];
    const fieldsToUpdate = {};
    let hasValidField = false;

    for (const field of allowedFields) {
        if (updateData[field] !== undefined) { // Check if field exists in updateData
            if (['discount_percent', 'tax_amount', 'transaction_fee', 'subtotal'].includes(field)) {
                // Parse numeric fields and validate, similar to createSale
                const parsedValue = parseFloat(updateData[field]);
                if (isNaN(parsedValue)) {
                    return res.status(400).json({ message: `Invalid numeric value for field: ${field}. Value received: "${updateData[field]}"` });
                }
                fieldsToUpdate[field] = parsedValue;
            } else {
                fieldsToUpdate[field] = updateData[field];
            }
            hasValidField = true;
        }
    }

    if (!hasValidField) {
        return res.status(400).json({ message: 'No valid fields provided for sale header update.' });
    }

    try {
        const { data, error } = await supabase
            .from('sale_header')
            .update(fieldsToUpdate)
            .eq('id', saleId)
            .select('*'); // Select the updated row

        if (error) {
            console.error(`Supabase Error - updateSaleHeader for ID ${saleId}:`, error);
            if (error.code === '23505' && error.constraint === 'sale_header_invoice_number_key') {
                return res.status(409).json({ message: 'Invoice number already exists.', error: error.message });
            }
            return res.status(500).json({ message: 'Error updating sale header in database', error: error.message });
        }

        if (data.length === 0) { // If no row was found and updated
            return res.status(404).json({ message: `Sale with ID ${saleId} not found.` });
        }

        console.log(`[${new Date().toISOString()}] Sale header ID ${saleId} updated in DB:`, data[0]);
        res.status(200).json(data[0]);
    } catch (err) {
        console.error("Server Error - updateSaleHeader:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// Delete a sale by ID (cascades to line items)
exports.deleteSale = async (req, res) => {
    const saleId = req.params.id;
    console.log(`[${new Date().toISOString()}] DELETE /api/sales/${saleId} called.`);

    // UUID validation
    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(saleId)) {
        return res.status(400).json({ message: 'Invalid Sale ID format (must be a UUID).' });
    }

    try {
        const { data, error } = await supabase
            .from('sale_header')
            .delete()
            .eq('id', saleId)
            .select('id'); // Select ID to confirm deletion

        if (error) {
            console.error(`Supabase Error - deleteSale for ID ${saleId}:`, error);
            return res.status(500).json({ message: 'Error deleting sale from database', error: error.message });
        }

        if (data.length === 0) { // If no row was found and deleted
            return res.status(404).json({ message: `Sale with ID ${saleId} not found.` });
        }

        console.log(`[${new Date().toISOString()}] Sale ID ${saleId} deleted successfully (including line items due to CASCADE).`);
        res.status(204).send(); // 204 No Content for successful deletion
    } catch (err) {
        console.error("Server Error - deleteSale:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// GET /api/sales/:saleId/receipt - Route to generate and download a receipt PDF
exports.generateReceiptPdf = async (req, res) => {
    const saleId = req.params.saleId;
    console.log(`[${new Date().toISOString()}] GET /api/sales/${saleId}/receipt called.`);

    // UUID validation
    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(saleId)) {
        return res.status(400).json({ message: 'Invalid Sale ID format (must be a UUID).' });
    }

    try {
        const { data: sale, error: saleError } = await supabase
            .from('sale_header')
            .select(`
                *,
                sale_items (
                    *,
                    products(name),       // Fetch product name for receipt
                    consignors(full_name) // Fetch consignor name for receipt
                )
            `)
            .eq('id', saleId)
            .single();

        if (saleError) {
            console.error(`Supabase Error - generateReceiptPdf (fetching sale) for ID ${saleId}:`, saleError);
            if (saleError.code === 'PGRST116') {
                return res.status(404).json({ message: `Sale with ID ${saleId} not found for receipt generation.` });
            }
            return res.status(500).json({ message: 'Error fetching sale data for receipt', error: saleError.message });
        }

        if (!sale) {
            return res.status(404).json({ message: `Sale with ID ${saleId} not found for receipt generation.` });
        }

        // --- PDF Generation Logic ---
        const doc = new PDFDocument({ margin: 50 });
        const filename = `receipt_sale_${sale.invoice_number || sale.id}.pdf`;

        // Set response headers for PDF download
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);

        // Pipe the PDF directly to the response
        doc.pipe(res);

        // Header Section
        doc.fontSize(28)
           .font('Helvetica-Bold')
           .text('SALES RECEIPT', { align: 'center' })
           .moveDown(0.8);

        doc.fontSize(12)
           .font('Helvetica')
           .text('Consignment Owner Store', { align: 'center' })
           .text('123 Main Street, Cityville, State, 12345', { align: 'center' })
           .text('Phone: (123) 456-7890 | Email: info@consignstore.com', { align: 'center' })
           .moveDown(1);

        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.8);

        // Sale Header Details
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Invoice Number:', { continued: true })
           .font('Helvetica')
           .text(` ${sale.invoice_number || 'N/A'}`);
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Sale Date:', { continued: true })
           .font('Helvetica')
           .text(` ${new Date(sale.sale_date).toLocaleDateString()} ${new Date(sale.sale_date).toLocaleTimeString()}`);
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Sale ID:', { continued: true })
           .font('Helvetica')
           .text(` ${sale.id}`);
        doc.moveDown(0.5);

        // Customer Details
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Customer Name:', { continued: true })
           .font('Helvetica')
           .text(` ${sale.customer_name || 'N/A'}`);
        if (sale.contact_type && sale.contact_info) {
            doc.fontSize(12)
               .font('Helvetica-Bold')
               .text(`Customer ${sale.contact_type}:`, { continued: true })
               .font('Helvetica')
               .text(` ${sale.contact_info}`);
        }
        doc.moveDown(1);

        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.8);

        // Line Items Table Header
        const itemTableTop = doc.y;
        const col1X = 50; // Qty
        const col2X = 100; // Item Name
        const col3X = 350; // Unit Price
        const col4X = 450; // Total

        doc.font('Helvetica-Bold')
           .fontSize(12)
           .text('Qty', col1X, itemTableTop, { width: 50 })
           .text('Item', col2X, itemTableTop, { width: 250 })
           .text('Unit Price', col3X, itemTableTop, { width: 100, align: 'right' })
           .text('Total', col4X, itemTableTop, { width: 100, align: 'right' });

        doc.moveDown(0.5);
        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.3);

        // Line Items Content
        doc.font('Helvetica').fontSize(11);
        sale.sale_items.forEach(item => {
            // Use product name if available from join, otherwise fallback
            const itemProductName = item.products?.name || `Product ID: ${item.product_id}`;
            const itemTotal = item.line_total.toFixed(2);
            doc.text(item.quantity.toString(), col1X, doc.y, { width: 50 });
            doc.text(itemProductName, col2X, doc.y, { width: 250 });
            doc.text(`$${item.unit_price.toFixed(2)}`, col3X, doc.y, { width: 100, align: 'right' });
            doc.text(`$${itemTotal}`, col4X, doc.y, { width: 100, align: 'right' });
            doc.moveDown(0.5);
        });

        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.8);

        // Financial Summary
        doc.font('Helvetica').fontSize(12);
        doc.text('Subtotal:', 350, doc.y, { width: 100, align: 'right', continued: true })
           .text(`$${sale.subtotal.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
           .moveDown(0.2);

        if (sale.discount_amount && sale.discount_amount > 0) {
            doc.text(`Discount (${sale.discount_percent}%):`, 350, doc.y, { width: 100, align: 'right', continued: true })
               .text(`-$${sale.discount_amount.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
               .moveDown(0.2);
        }

        doc.text('Tax Amount:', 350, doc.y, { width: 100, align: 'right', continued: true })
           .text(`$${sale.tax_amount.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
           .moveDown(0.2);

        doc.text('Transaction Fee:', 350, doc.y, { width: 100, align: 'right', continued: true })
           .text(`$${sale.transaction_fee.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
           .moveDown(0.5);

        doc.font('Helvetica-Bold').fontSize(16);
        doc.text('GRAND TOTAL:', 350, doc.y, { width: 100, align: 'right', continued: true })
           .text(`$${sale.total_amount.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
           .moveDown(1);

        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.8);

        // Footer Information
        doc.font('Helvetica').fontSize(12);
        doc.text(`Payment Method: ${sale.payment_method}`).moveDown(0.5);
        if (sale.notes) {
            doc.font('Helvetica-Bold').text('Notes:').moveDown(0.2);
            doc.font('Helvetica').text(sale.notes).moveDown(0.5);
        }

        doc.font('Helvetica-Oblique').fontSize(10).text('Thank you for your purchase!', { align: 'center', absoluteBottom: 50 });

        doc.end(); // Finalize the PDF
        // --- End PDF Generation Logic ---

    } catch (err) {
        console.error("Server Error - generateReceiptPdf:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};